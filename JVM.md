##认识JVM
   + JVM是JAVA Virtual Machine的简称，意味JAVA虚拟机
   + 最为广泛使用的JVM是HotSpot
###支持的数据类型
   + byte://1字节有符号整数的补码
   + short://2字节有符号整数的补码
   + int://4字节有符号整数的补码
   + long://8字节有符号整数的补码
   + float://4字节IEEE754单精度浮点数
   + double://8字节IEEE754双精度浮点数
   + char://2字节无符号Unicode字符
   + boolean:boolean数据类型表示一位的信息
   + object//对一个Javaobject（对象）的4字节引用
   + returnAddress//4字节，用于jsr/ret/jsr-w/ret-w指令
   + Java数组被当做object处理
###JVM基本结构
![JVM基本结构]https://github.com/Only-TEL/concurrencys/blob/master/JVM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png
###JVM基本结构-类装在子系统
   + 在JAVA虚拟机中，负责查找并装载类型的那部分被称为类装载子系统。
　 
   > JAVA虚拟机有两种类装载器：启动类装载器和用户自定义类装载器。前者是JAVA虚拟机实现的一部分，后者则是Java程序的一部分。
   > 由不同的类装载器装载的类将被放在虚拟机内部的不同命名空间中。
　　
   + 类装载器子系统涉及Java虚拟机的其他几个组成部分，以及几个来自java.lang库的类。比如，用户自定义的类装载器是普通的Java对象，它的类必须派生自java.lang.ClassLoader类。
   + ClassLoader中定义的方法为程序提供了访问类装载器机制的接口。
   + 此外，对于每一个被装载的类型，JAVA虚拟机都会为它创建一个java.lang.Class类的实例来代表该类型。和所有其他对象一样，用户自定义的类装载器以及Class类的实例都放在内存中的堆区，而装载的类型信息则都位于方法区。
   ***
   + 类装载器子系统除了要定位和导入二进制class文件外，还必须负责验证被导入类的正确性，为类变量分配并初始化内存，以及帮助解析符号引用。这些动作必须严格按以下顺序进行：
   + 　（1）装载——查找并装载类型的二进制数据。
   + 　（2）连接——指向验证、准备、以及解析（可选）。
       1. 验证　　确保被导入类型的正确性。（java可以自定义安全策略等）
       2. 准备　　为类变量(静态成员变量)分配内存，并将其初始化为默认值。（这里的准备和下面的初始化的顺序问题体现在java初始化中值变化的各种陷阱）      
       3. 解析　　把类型中的符号引用转换为直接引用。       
   +  （3）初始化——把类变量初始化为正确初始值。（准备的时候设为默认值，此时才会正式给变量赋值）
   + 每个JAVA虚拟机实现都必须有一个启动类装载器，它知道怎么装载受信任的类。
   + 每个类装载器都有自己的命名空间，其中维护着由它装载的类型。所以一个Java程序可以多次装载具有同一个全限定名的多个类型。这样一个类型的全限定名就不足以确定在一个Java虚拟机中的唯一性。因此，当多个类装载器都装载了同名的类型时，为了惟一地标识该类型，还要在类型名称前加上装载该类型（指出它所位于的命名空间）的类装载器标识。
###JVM基本结构-直接内存
   ```
       直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是JAVA虚拟机规范中定义的内存区域。但是这部分内存也被频繁使用。而且也可能导致OutOfMemoryError异常出现。
   在JDK1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为
   这块内存的引用进行操作。这样能在一些场景中显著提高性能，避免了在JAVA堆和Native堆中来回复制数据
       显然，本机直接内存的分配不会受到java堆大小的限制，但是既然是内存就必定会受到本机主内存(包括RAM以及SWAP区或者分页文件)大小以及处理器寻址空间的限制。
   服务器管理员在配置虚拟机的参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制(包括物理和操作系统级的限制)，从而导致动态扩展时出现OutOfMemoryError异常
   ```
   + Java的NIO库允许java程序使用直接内存，从而提高性能，通常直接内存速度会优于java堆。读写频繁的场合可能会考虑使用
###JVM基本结构-方法区
   + 方法区和堆一样，方法区是一块所有线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。当方法区无法满足内存分配需求时，将抛出OutOfMemorryError异常。
   方法区的大小决定了系统可以保存多少个类，如果系统定义太多的类，导致方法区溢出。虚拟机同样会抛出内存溢出错误。方法区可以理解为永久区（Perm） 
   + 运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存储编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。
###JVM基本结构-JAVA堆
   + Java堆是Java虚拟机所管理的内存中最大的一块。在虚拟机启动时创建，此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。  
   + JAVA堆是垃圾收集器管理的主要区域，因此也称为“GC堆”；
   + 如果堆中没有内存完成实例分配，并且堆也无法扩展时，将会抛出OutOfMemoryError异常。
   ![JAVA堆]https://github.com/Only-TEL/concurrencys/blob/master/JVM%20Stack.png
###JVM基本结构-JAVA虚拟机栈
   + Java虚拟栈，线程私有的，它的生命周期与线程相同。
   + 每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、方法调用、方法出口（方法参数，返回值）等信息。
   + 这个区域有两个异常：
    1、如果线程请求的栈深度大于虚拟锁允许的深度，将抛StackOverflowError异常；
    2、虚拟机栈可以动态扩展，但扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。
   + 一个栈，一般由三部分组成：局部变量表、操作数栈和帧数据区
   + 局部变量表：用于报错函数的参数及局部变量
   + 操作数栈：主要保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。
   + 帧数据区：除了局部变量表和操作数栈以外，栈还需要一些数据来支持常量池的解析，这里帧数据区保存着访问常量池的指针，方便程序访问常量池，另外，当函数返回或者出现异常时，虚拟机必须有一个异常处理表，方便发送异常的时候找到异常的代码，因此异常处理也是帧数据区的一部分。
###JVM基本结构-本地方法栈
   + 本地方法栈作用与虚拟机相似，区别在于虚拟机为虚拟机执行java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。
   + Native方法常用与两种请求:
    1、在方法中调用一些不是有java语言写的代码；
    2、在方法中用java语言直接操作计算机硬件；
   + 异常：StackOverflowError、OutOfMemoryError
###JVM基本结构-垃圾收集系统
   + 垃圾收集系统是java的核心，也是必不可少的，java有一套自己进行垃圾清理的机制，开发人员无需手工清理



###JVM基本结构-程序计数器
   + 线程私有的内存，是一个较小的内存空间，它可以看做当前线程所执行的字节码的行号指示器。Java虚拟机规范中唯一一个没有OutOfMemoryError情况的区域。
   + PC寄存器也是每个线程私有的空间，java虚拟机会为每个线程创建PC寄存器，在任意时刻，一个java线程总是执行一个方法，这个方法被称为当前方法，如果当前方法不是本地方法，PC寄存器值为undefined,寄存器存放如当前执行环境指针、程序计数器、操作栈指针、计算的变量指针等信息。
###JVM基本结构-执行引擎
   + 虚拟机最核心的组件就是执行引擎了，它负责执行虚拟机的字节码。一般会先执行编译成机器码后执行。
###JVM基本结构-堆栈方法区概念和联系
   + 堆解决的是数据存储的问题，即数据怎么放、放在哪。
   + 栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。
   + 方法区则是辅助栈的快永久区，解决堆栈信息的产生，是先决条件。

详见JVM.doc










   